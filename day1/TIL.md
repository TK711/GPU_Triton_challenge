개념CUDATriton실행 단위블록 > 스레드 (2단계)프로그램 (1단계)데이터 처리1 스레드 = 1 요소1 프로그램 = N 요소 (벡터화)인덱스 계산blockIdx + threadIdxprogram_id + arange병렬화 수준스레드 레벨 (세밀)데이터 블록 레벨 (추상화)메모리 접근array[index]load(pointer + offsets)

🎯 핵심 요약
작성자는 CUDA의 스레드 모델을 Triton에 1:1 매핑하려 했지만:

Triton은 더 고수준 추상화

스레드를 직접 다루지 않음
프로그램이 데이터 블록을 벡터 단위로 처리


용어의 차이

"블록/스레드" → "프로그램/데이터 블록"
"스레드 개수" → "처리할 데이터 개수"


사고방식 전환 필요

CUDA: "몇 개의 스레드가 필요한가?"
Triton: "각 프로그램이 몇 개씩 처리할까?"

프로그램(Program) = 하나의 독립적인 실행 단위

하나의 커널 함수 인스턴스
벡터화된 데이터 블록을 처리하는 작업 단위
내부적으로는 여러 스레드로 실행되지만, 프로그래머는 이를 신경쓰지 않음

CUDA <> triton, 스레드 중심 vs 데이터 블록 중심

CUDA의 관점:

* 프로그래머가 스레드 개수를 직접 계산
* 각 스레드는 정확히 1개의 데이터만 처리
* 스레드 ID를 통해 어떤 데이터를 처리할지 결정

Triton의 관점:

* 프로그래머는 데이터를 몇 개씩 묶을지만 결정
* 각 프로그램은 BLOCK_SIZE개의 데이터를 벡터로 처리
* 스레드는 컴파일러가 알아서 관리

📊 핵심 차이 요약표
측면CUDATriton추상화 수준낮음 (스레드 직접 제어)높음 (데이터 블록 제어)프로그래머가 보는 것개별 스레드데이터 벡터실제 실행스레드 그대로 실행컴파일러가 스레드로 변환데이터 처리 단위1개 (스칼라)N개 (벡터)최적화수동 (프로그래머)자동 (컴파일러)난이도어려움쉬움

🎯 결론
Triton의 "프로그램"은:

논리적으로는 데이터 블록을 처리하는 단위
물리적으로는 여러 CUDA 스레드로 실행됨 (내부적으로)
프로그래머는 벡터 연산을 작성하면, 컴파일러가 효율적인 스레드 코드로 변환

차이가 발생하는 이유:

CUDA: "스레드 10000개 어떻게 조직할까?" (How)
Triton: "데이터 10000개 어떻게 나눌까?" (What)